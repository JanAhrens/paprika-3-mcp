package main

import (
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/soggycactus/paprika-3-mcp/internal/paprika"
)

var version = "dev" // set during build with -ldflags

type RecipeSummary struct {
	UID         string `json:"uid"`
	Name        string `json:"name"`
	Description string `json:"description"`
	URI         string `json:"uri"`
}

func main() {
	username := flag.String("username", "", "Paprika 3 username (email)")
	password := flag.String("password", "", "Paprika 3 password")
	showVersion := flag.Bool("version", false, "Print version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("paprika-3-mcp version %s\n", version)
		os.Exit(0)
	}

	if *username == "" || *password == "" {
		fmt.Fprintln(os.Stderr, "username and password are required")
		os.Exit(1)
	}

	s := server.NewMCPServer("paprika-3-mcp", "1.0.0", server.WithLogging(), server.WithResourceCapabilities(true, true))
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))

	paprika3, err := paprika.NewClient(*username, *password, logger)
	if err != nil {
		slog.Error("failed to create paprika client", "error", err)
		os.Exit(1)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// List all recipes to expose them as resources
	recipes, err := paprika3.ListRecipes(ctx)
	if err != nil {
		slog.Error("failed to list recipes", "error", err)
		os.Exit(1)
	}

	for _, r := range recipes.Result {
		recipe, err := paprika3.GetRecipe(ctx, r.UID)
		if err != nil {
			slog.Error("failed to get recipe", "error", err)
			continue
		}

		if recipe.InTrash {
			continue
		}

		jsonString, err := json.Marshal(recipe)
		if err != nil {
			slog.Error("failed to marshal recipe", "error", err)
			continue
		}
		resourceContents := mcp.TextResourceContents{
			URI:      fmt.Sprintf("paprika://recipes/%s", r.UID),
			MIMEType: "application/json",
			Text:     string(jsonString),
		}

		resourceDescription := func(r *paprika.Recipe) string {
			if len(r.Description) == 0 {
				return fmt.Sprintf("A recipe for %s", r.Name)
			}

			return fmt.Sprintf("A recipe for %s: %s", r.Name, r.Description)
		}

		s.AddResource(mcp.NewResource(fmt.Sprintf("paprika://recipes/%s", r.UID), recipe.Name, mcp.WithResourceDescription(resourceDescription(recipe)), mcp.WithMIMEType("application/json")), func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
			return []mcp.ResourceContents{resourceContents}, nil
		})
	}

	createRecipeTool := mcp.NewTool("create_paprika_recipe",
		mcp.WithDescription("Save new recipes generated by LLMs in the Paprika 3 app"),
		mcp.WithString("name", mcp.Description("The name of the recipe"), mcp.Required()),
		mcp.WithString("ingredients", mcp.Description("The ingredients of the recipe"), mcp.Required()),
		mcp.WithString("directions", mcp.Description("The directions for the recipe"), mcp.Required()),
		mcp.WithString("description", mcp.Description("The description of the recipe"), mcp.DefaultString("")),
		mcp.WithString("notes", mcp.Description("The notes for the recipe"), mcp.DefaultString("")),
		mcp.WithString("servings", mcp.Description("The number of servings for the recipe"), mcp.DefaultString("")),
		mcp.WithString("prep_time", mcp.Description("The prep time for the recipe"), mcp.DefaultString("")),
		mcp.WithString("cook_time", mcp.Description("The cook time for the recipe"), mcp.DefaultString("")),
		mcp.WithString("difficulty", mcp.Description("The difficulty of the recipe"), mcp.DefaultString("")),
	)

	s.AddTool(createRecipeTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		name, ok := req.Params.Arguments["name"].(string)
		if !ok || len(name) == 0 {
			return nil, errors.New("name is required")
		}
		ingredients, ok := req.Params.Arguments["ingredients"].(string)
		if !ok || len(ingredients) == 0 {
			return nil, errors.New("ingredients are required")
		}
		directions, ok := req.Params.Arguments["directions"].(string)
		if !ok || len(directions) == 0 {
			return nil, errors.New("directions are required")
		}
		servings := req.Params.Arguments["servings"].(string)
		prepTime := req.Params.Arguments["prep_time"].(string)
		cookTime := req.Params.Arguments["cook_time"].(string)
		description := req.Params.Arguments["description"].(string)
		notes := req.Params.Arguments["notes"].(string)
		difficulty := req.Params.Arguments["difficulty"].(string)

		recipe, err := paprika3.SaveRecipe(ctx, paprika.Recipe{
			Name:        name,
			Ingredients: ingredients,
			Directions:  directions,
			Description: description,
			Servings:    servings,
			PrepTime:    prepTime,
			CookTime:    cookTime,
			Notes:       notes,
			Difficulty:  difficulty,
		})
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultResource(recipe.Name, mcp.TextResourceContents{
			URI:      fmt.Sprintf("paprika://recipes/%s", recipe.UID),
			MIMEType: "application/json",
		}), nil
	})

	updateRecipeTool := mcp.NewTool("update_paprika_recipe",
		mcp.WithDescription("Update existing recipes in the Paprika 3 app"),
		mcp.WithString("uid", mcp.Description("The UID of the recipe"), mcp.Required()),
		mcp.WithString("name", mcp.Description("The name of the recipe"), mcp.Required()),
		mcp.WithString("ingredients", mcp.Description("The ingredients of the recipe"), mcp.Required()),
		mcp.WithString("directions", mcp.Description("The directions for the recipe"), mcp.Required()),
		mcp.WithString("description", mcp.Description("The description of the recipe"), mcp.Required()),
		mcp.WithString("notes", mcp.Description("The notes for the recipe"), mcp.Required()),
		mcp.WithString("servings", mcp.Description("The number of servings for the recipe"), mcp.Required()),
		mcp.WithString("prep_time", mcp.Description("The prep time for the recipe"), mcp.Required()),
		mcp.WithString("cook_time", mcp.Description("The cook time for the recipe"), mcp.Required()),
		mcp.WithString("difficulty", mcp.Description("The difficulty of the recipe"), mcp.Required()),
	)

	s.AddTool(updateRecipeTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		uid, ok := req.Params.Arguments["uid"].(string)
		if !ok || len(uid) == 0 {
			return nil, errors.New("uid is required")
		}
		name, ok := req.Params.Arguments["name"].(string)
		if !ok || len(name) == 0 {
			return nil, errors.New("name is required")
		}
		ingredients, ok := req.Params.Arguments["ingredients"].(string)
		if !ok || len(ingredients) == 0 {
			return nil, errors.New("ingredients are required")
		}
		directions, ok := req.Params.Arguments["directions"].(string)
		if !ok || len(directions) == 0 {
			return nil, errors.New("directions are required")
		}
		description, ok := req.Params.Arguments["description"].(string)
		if !ok {
			return nil, errors.New("description is required")
		}
		servings, ok := req.Params.Arguments["servings"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		prepTime, ok := req.Params.Arguments["prep_time"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		cookTime, ok := req.Params.Arguments["cook_time"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		notes, ok := req.Params.Arguments["notes"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		difficulty, ok := req.Params.Arguments["difficulty"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}

		recipe, err := paprika3.SaveRecipe(ctx, paprika.Recipe{
			UID:         uid,
			Name:        name,
			Ingredients: ingredients,
			Directions:  directions,
			Description: description,
			Servings:    servings,
			PrepTime:    prepTime,
			CookTime:    cookTime,
			Notes:       notes,
			Difficulty:  difficulty,
		})
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultResource(recipe.Name, mcp.TextResourceContents{
			URI:      fmt.Sprintf("paprika://recipes/%s", recipe.UID),
			MIMEType: "application/json",
		}), nil
	})

	getAllRecipesTool := mcp.NewTool("list_recipe_summaries",
		mcp.WithDescription("Get a summary list of all available recipes. Use the recipe resource endpoints to fetch full details for specific recipes."),
	)

	s.AddTool(getAllRecipesTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		recipes, err := paprika3.ListRecipes(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to list recipes: %w", err)
		}

		// Create summarized version of recipes
		summaries := make([]RecipeSummary, 0, len(recipes.Result))
		for _, r := range recipes.Result {
			recipe, err := paprika3.GetRecipe(ctx, r.UID)
			if err != nil {
				slog.Error("failed to get recipe", "error", err)
				continue
			}

			if recipe.InTrash {
				continue
			}

			summaries = append(summaries, RecipeSummary{
				UID:         recipe.UID,
				Name:        recipe.Name,
				Description: recipe.Description,
				URI:         fmt.Sprintf("paprika://recipes/%s", recipe.UID),
			})
		}

		jsonString, err := json.Marshal(summaries)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal recipe summaries: %w", err)
		}

		return mcp.NewToolResultResource("recipe_summaries", mcp.TextResourceContents{
			URI:      "paprika://recipes/summaries",
			MIMEType: "application/json",
			Text:     string(jsonString),
		}), nil
	})

	if err := server.ServeStdio(s); err != nil {
		slog.Error("Server error", "error", err)
	}
}
