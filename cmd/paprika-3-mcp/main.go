package main

import (
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/soggycactus/paprika-3-mcp/internal/paprika"
)

func main() {
	username := flag.String("username", "", "Paprika 3 username (email)")
	password := flag.String("password", "", "Paprika 3 password")
	flag.Parse()

	if *username == "" || *password == "" {
		fmt.Fprintln(os.Stderr, "username and password are required")
		os.Exit(1)
	}

	s := server.NewMCPServer("paprika-3-mcp", "1.0.0", server.WithLogging(), server.WithResourceCapabilities(false, false))
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))

	paprika3, err := paprika.NewClient(*username, *password, logger)
	if err != nil {
		slog.Error("failed to create paprika client", "error", err)
		os.Exit(1)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// List all recipes to expose them as resources
	recipes, err := paprika3.ListRecipes(ctx)
	if err != nil {
		slog.Error("failed to list recipes", "error", err)
		os.Exit(1)
	}

	for _, r := range recipes.Result {
		recipe, err := paprika3.GetRecipe(ctx, r.UID)
		if err != nil {
			slog.Error("failed to get recipe", "error", err)
			continue
		}

		if recipe.InTrash {
			continue
		}

		jsonString, err := json.Marshal(recipe)
		if err != nil {
			slog.Error("failed to marshal recipe", "error", err)
			continue
		}
		resourceContents := mcp.TextResourceContents{
			URI:      fmt.Sprintf("paprika://recipes/%s", r.UID),
			MIMEType: "application/json",
			Text:     string(jsonString),
		}

		resourceDescription := func(r *paprika.Recipe) string {
			if len(r.Description) == 0 {
				return fmt.Sprintf("A recipe for %s", r.Name)
			}

			return fmt.Sprintf("A recipe for %s: %s", r.Name, r.Description)
		}

		s.AddResource(mcp.NewResource(fmt.Sprintf("paprika://recipes/%s", r.UID), recipe.Name, mcp.WithResourceDescription(resourceDescription(recipe)), mcp.WithMIMEType("application/json")), func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
			return []mcp.ResourceContents{resourceContents}, nil
		})

		slog.Info("Added resource", "name", recipe.Name, "uid", r.UID)
	}

	createRecipeTool := mcp.NewTool("create_paprika_recipe",
		mcp.WithDescription("Save new recipes generated by LLMs in the Paprika 3 app"),
		mcp.WithString("name", mcp.Description("The name of the recipe"), mcp.Required()),
		mcp.WithString("ingredients", mcp.Description("The ingredients of the recipe"), mcp.Required()),
		mcp.WithString("directions", mcp.Description("The directions for the recipe"), mcp.Required()),
		mcp.WithString("notes", mcp.Description("The notes for the recipe"), mcp.DefaultString("")),
		mcp.WithString("servings", mcp.Description("The number of servings for the recipe"), mcp.DefaultString("")),
		mcp.WithString("prep_time", mcp.Description("The prep time for the recipe"), mcp.DefaultString("")),
		mcp.WithString("cook_time", mcp.Description("The cook time for the recipe"), mcp.DefaultString("")),
		mcp.WithString("difficulty", mcp.Description("The difficulty of the recipe"), mcp.DefaultString("")),
	)

	s.AddTool(createRecipeTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		name, ok := req.Params.Arguments["name"].(string)
		if !ok || len(name) == 0 {
			return nil, errors.New("name is required")
		}
		ingredients, ok := req.Params.Arguments["ingredients"].(string)
		if !ok || len(ingredients) == 0 {
			return nil, errors.New("ingredients are required")
		}
		directions, ok := req.Params.Arguments["directions"].(string)
		if !ok || len(directions) == 0 {
			return nil, errors.New("directions are required")
		}
		servings := req.Params.Arguments["servings"].(string)
		prepTime := req.Params.Arguments["prep_time"].(string)
		cookTime := req.Params.Arguments["cook_time"].(string)
		notes := req.Params.Arguments["notes"].(string)
		difficulty := req.Params.Arguments["difficulty"].(string)

		recipe, err := paprika3.SaveRecipe(ctx, paprika.Recipe{
			Name:        name,
			Ingredients: ingredients,
			Directions:  directions,
			Servings:    servings,
			PrepTime:    prepTime,
			CookTime:    cookTime,
			Notes:       notes,
			Difficulty:  difficulty,
		})
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultResource(recipe.Name, mcp.TextResourceContents{
			URI:      fmt.Sprintf("paprika://recipes/%s", recipe.UID),
			MIMEType: "application/json",
		}), nil
	})

	updateRecipeTool := mcp.NewTool("update_paprika_recipe",
		mcp.WithDescription("Update existing recipes in the Paprika 3 app"),
		mcp.WithString("uid", mcp.Description("The UID of the recipe"), mcp.Required()),
		mcp.WithString("name", mcp.Description("The name of the recipe"), mcp.Required()),
		mcp.WithString("ingredients", mcp.Description("The ingredients of the recipe"), mcp.Required()),
		mcp.WithString("directions", mcp.Description("The directions for the recipe"), mcp.Required()),
		mcp.WithString("notes", mcp.Description("The notes for the recipe"), mcp.Required()),
		mcp.WithString("servings", mcp.Description("The number of servings for the recipe"), mcp.Required()),
		mcp.WithString("prep_time", mcp.Description("The prep time for the recipe"), mcp.Required()),
		mcp.WithString("cook_time", mcp.Description("The cook time for the recipe"), mcp.Required()),
		mcp.WithString("difficulty", mcp.Description("The difficulty of the recipe"), mcp.Required()),
	)

	s.AddTool(updateRecipeTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		uid, ok := req.Params.Arguments["uid"].(string)
		if !ok || len(uid) == 0 {
			return nil, errors.New("uid is required")
		}
		name, ok := req.Params.Arguments["name"].(string)
		if !ok || len(name) == 0 {
			return nil, errors.New("name is required")
		}
		ingredients, ok := req.Params.Arguments["ingredients"].(string)
		if !ok || len(ingredients) == 0 {
			return nil, errors.New("ingredients are required")
		}
		directions, ok := req.Params.Arguments["directions"].(string)
		if !ok || len(directions) == 0 {
			return nil, errors.New("directions are required")
		}
		servings, ok := req.Params.Arguments["servings"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		prepTime, ok := req.Params.Arguments["prep_time"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		cookTime, ok := req.Params.Arguments["cook_time"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		notes, ok := req.Params.Arguments["notes"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}
		difficulty, ok := req.Params.Arguments["difficulty"].(string)
		if !ok {
			return nil, errors.New("difficulty is required")
		}

		recipe, err := paprika3.SaveRecipe(ctx, paprika.Recipe{
			UID:         uid,
			Name:        name,
			Ingredients: ingredients,
			Directions:  directions,
			Servings:    servings,
			PrepTime:    prepTime,
			CookTime:    cookTime,
			Notes:       notes,
			Difficulty:  difficulty,
		})
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultResource(recipe.Name, mcp.TextResourceContents{
			URI:      fmt.Sprintf("paprika://recipes/%s", recipe.UID),
			MIMEType: "application/json",
		}), nil
	})

	if err := server.ServeStdio(s); err != nil {
		slog.Error("Server error", "error", err)
	}
}
